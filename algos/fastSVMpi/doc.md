это реализация алгоритма с использованием кастомного распределителя

# Описание структуры алгоритма

Есть три типа вычислительных узлов: мастер, слейв и роутер. Так как mpi работает на концепции
"Один код, разное поведение", то тип вычислительного узла вычисляется в процессе исполнения программы.

Определим структуру transRole. Она быдет содержать поля-ссылки на обыъекты master, slave и router,
а так же флаг принадлежности к одному из этих классов и mpi_rank. Также transRole содержит в себе контекст программы (коммуникатор) и гиперпараметры (количество роутеров, слейвов, размер мира, хеш-нам).

Таким образом, на каждом вычислительном узле будет существовать единственный объект transRole, 
содержащий состояние данного вычислительного узла и глобальный контекст (обзий для всех узлов).

Алгоритм большой и муторный - постарался его декомпозировать на несколько стадий, 
каждая в своем файле. В файле есть входная функция данной стадии алгоритма, принимающая объект transRole.
В зависимости от типа вычислительного узла, от этого объекта будет вызвана функция, описывающая поведение 
конкретного типа объекта на текущей стадии алгритма.

# Описание сущностей

## Slave 
Данная версия алгоритма работает на основе какого-то (надеюсь) эффективного распределения
узлов графа по слейвам.
Поэтому было бы хорошо оптимизировать обработку ребер, оба конца которых лежат на одном узле.


# Стадии

## Стадия 0 - инициализация

Инициализируется мир, создаются объекты transRole.

## Стадия 1 - распределение обязанностей и знакомство

В общем виде вычисление это отображение из множества индексов узлов, 
в множество индексов слейвов. Оно не представляет из себя функциональную зависимость.
Предполагается, что на одном роутере не может храниться весь словарь распределения полностью, 
поэтому он распределяется по нескольким роутерам по следущему правилу:

Пусть $N$ - число хешей, $M$ - количество роутеров, тогда каждый роутер обслуживает $k = N/M$ хешей 
(кроме, может быть, последнего роутера). Роутеры проиндексированны, 
$j$-й роутер обслуживает хеши: $k_i$ такие, что $k_i \% M = 0$.

1. Мастер читает граф, создает распределение
2. Раздача распределения